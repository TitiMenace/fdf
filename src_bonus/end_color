cinematic_hooks.c:20:		data->set_cinematic = !data->set_cinematic;
cinematic_hooks.c:22:		data->isometric = !data->isometric;
cinematic_hooks.c:24:		data->special_rendering = !data->special_rendering;
cinematic_hooks.c:26:		data->set_alpha_mode = !data->set_alpha_mode;
cinematic_hooks.c:28:		data->fast_mode = !data->fast_mode;
cinematic_hooks.c:34:		data->offset = data->offset * 1.1;
cinematic_hooks.c:35:	if (zazou == XK_BackSpace && data->offset > 0)
cinematic_hooks.c:36:		data->offset = data->offset * 0.9;
cinematic_hooks.c:38:		data->line.start_y = data->line.start_y - 10;
cinematic_hooks.c:40:		data->line.start_y = data->line.start_y + 10;
cinematic_hooks.c:42:		data->line.start_x = data->line.start_x - 10;
cinematic_hooks.c:44:		data->line.start_x = data->line.start_x + 10;
cinematic_hooks.c:45:	if (data->isometric == false)
cinematic_hooks.c:48:			data->fov += 1;
cinematic_hooks.c:50:			data->fov -= 1;
cinematic_hooks.c:51:		//dprintf(2, "fov %f\n", data->fov);
cinematic_hooks.c:57:	if (zazou == XK_e && data->cinematic_x >= -1)
cinematic_hooks.c:58:		data->cinematic_x -= 0.1;
cinematic_hooks.c:59:	if (zazou == XK_r && data->cinematic_x <= 1)
cinematic_hooks.c:60:		data->cinematic_x += 0.1;
cinematic_hooks.c:61:	if (zazou == XK_d && data->cinematic_y >= -1)
cinematic_hooks.c:62:		data->cinematic_y -= 0.1;
cinematic_hooks.c:63:	if (zazou == XK_f && data->cinematic_y <= 1)
cinematic_hooks.c:64:		data->cinematic_y += 0.1;
cinematic_hooks.c:65:	if (zazou == XK_c && data->cinematic_z >= -1)
cinematic_hooks.c:66:		data->cinematic_z -= 0.1;
cinematic_hooks.c:67:	if (zazou == XK_v && data->cinematic_z <= 1)
cinematic_hooks.c:68:		data->cinematic_z += 0.1;
cinematic_hooks.c:69:	if (zazou == XK_k && data->cinematic >= 0)
cinematic_hooks.c:70:		data->cinematic -= 0.1;
cinematic_hooks.c:71:	if (zazou == XK_l && data->cinematic <= 1)
cinematic_hooks.c:72:		data->cinematic += 0.1;
cinematic_hooks.c:78:		data->angle.angle_x -= 5;
cinematic_hooks.c:80:		data->angle.angle_x += 5;
cinematic_hooks.c:82:		data->angle.angle_y -= 5;
cinematic_hooks.c:84:		data->angle.angle_y += 5;
cinematic_hooks.c:86:		data->angle.angle_z -= 5;
cinematic_hooks.c:88:		data->angle.angle_z += 5;
color.c:23://	if (data->z_min == data->z_max)
colors_hooks.c:19:	if (zazou == XK_h && data->alpha + 10 <= 255)
colors_hooks.c:20:		data->alpha += 10;
colors_hooks.c:21:	if (zazou == XK_j && data->alpha - 10 >= 0)
colors_hooks.c:22:		data->alpha -= 10;
colors_hooks.c:29:		if (data->end_color == 0)
colors_hooks.c:31:			data->start_color = 0x000000FF;
colors_hooks.c:32:			data->end_color = 0x0000FFFF;
colors_hooks.c:34:		else if (data->start_color == 0x000000FF)
colors_hooks.c:36:			data->start_color = 0x00FF0000;
colors_hooks.c:37:			data->end_color = 0x00FFFF00;
colors_hooks.c:39:		else if (data->end_color == 0x00FFFF00)
colors_hooks.c:41:			data->start_color = 0x007F00FF;
colors_hooks.c:42:			data->end_color = 0x00FF007F;
colors_hooks.c:46:			data->start_color = 0x00FFFFFF;
colors_hooks.c:47:			data->end_color = 0;
draw_helper.c:20:		- ((float)data->line_len[0] / 2), ((float)i
draw_helper.c:21:			- (float)data->len_y / 2) + 1, (*map)[i + 1][j].z);
draw_helper.c:22:	init_rot(&data->draw_helper.down, data->rot_hlp, \
draw_helper.c:24:	if (data->special_rendering == true)
draw_helper.c:25:		init_special_rotations(&data->draw_helper.down, data);
draw_helper.c:27:		init_rotations(&data->draw_helper.down, data);
draw_helper.c:28:	draw(&data->draw_helper.origin, &data->draw_helper.down, \
draw_helper.c:29:		data, &(data->line));
draw_helper.c:34:	if (j + 1 == data->line_len[i])
draw_helper.c:37:		- ((float)data->line_len[0] / 2) + 1, (float)i
draw_helper.c:38:		- (float)data->len_y / 2, (*map)[i][j + 1].z);
draw_helper.c:39:	init_rot(&data->draw_helper.right, data->rot_hlp, \
draw_helper.c:41:	if (data->special_rendering == true)
draw_helper.c:42:		init_special_rotations(&data->draw_helper.right, data);
draw_helper.c:44:		init_rotations(&data->draw_helper.right, data);
draw_helper.c:45:	draw(&data->draw_helper.origin, &data->draw_helper.right, \
draw_helper.c:46:		data, &(data->line));
draw_helper.c:53:		- ((float)data->line_len[0] / 2) + 1, (float)i
draw_helper.c:54:		- (float)data->len_y / 2, (*map)[i][j + 1].z);
draw_helper.c:55:	init_rot(&data->draw_helper.right, data->rot_hlp, \
draw_helper.c:58:		- ((float)data->line_len[0] / 2), ((float)i
draw_helper.c:59:			- (float)data->len_y / 2) + 1, (*map)[i + 1][j].z);
draw_helper.c:60:	init_rot(&data->draw_helper.down, data->rot_hlp, \
draw_helper.c:62:	init_rotations(&data->draw_helper.right, data);
draw_helper.c:63:	if (data->special_rendering == true)
draw_helper.c:64:		init_special_rotations(&data->draw_helper.down, data);
draw_helper.c:66:		init_rotations(&data->draw_helper.down, data);
draw_helper.c:67:	draw(&data->draw_helper.origin, &data->draw_helper.right, \
draw_helper.c:68:		data, &(data->line));
draw_helper.c:69:	if (j < data->line_len[i + 1])
draw_helper.c:71:		draw(&data->draw_helper.origin, &data->draw_helper.down, \
draw_helper.c:72:			data, &(data->line));
draw_helper.c:78:	if (j + 1 == data->line_len[i] && i + 1 != data->len_y)
draw_helper.c:80:		if (j < data->line_len[i + 1])
draw_helper.c:83:	else if (i + 1 == data->len_y)
draw_line_utils.c:19:	if (seg->col_b != 0 && data->end_color == 0)
draw_line_utils.c:21:	else if (seg->col_a != 0 && data->end_color == 0)
draw_line_utils.c:32:		&& (seg->a_x >= 0 && seg->a_x <= data->mlx.w_w)
draw_line_utils.c:33:		&& (seg->a_y >= 0 && seg->a_y <= data->mlx.w_h
draw_line_utils.c:34:			&& !(data->isometric == false && (seg->a_z + data->fov
draw_line_utils.c:35:					<= 0 && seg->b_z + data->fov <= 0))))
draw_line_utils.c:39:						- seg->z1_origin)) - data->z_min)
draw_line_utils.c:40:			/ (data->z_max - data->z_min);
draw_line_utils.c:56:		if (data->z_max == data->z_min)
draw_line_utils.c:60:							- seg->z1_origin)) - data->z_min)
draw_line_utils.c:61:				/ (data->z_max - data->z_min);
draw_line_utils.c:62:		if ((seg->a_x >= data->mlx.w_w || seg->a_y >= data->mlx.w_h || seg->a_x < 0 || seg->a_y < 0))
draw_line_utils.c:64:		if (!(seg->a_x >= data->mlx.w_w || seg->a_y >= data->mlx.w_h || seg->a_x < 0 || seg->a_y < 0) &&
draw_line_utils.c:65:				(data->isometric == true || (seg->a_z + data->fov > 0 && seg->b_z + data->fov > 0)))
draw_line_utils.c:69:			if (data->fast_mode)
draw_line_utils.c:84:	//	if (!(seg->a_x >= data->mlx.w_w || seg->a_y >= data->mlx.w_h || seg->a_x < 0 || seg->a_y < 0))
draw_line_utils.c:91:	if (seg->col_a != 0 && data->end_color == 0)
draw_line_utils.c:94:		help->color1 = data->start_color;
draw_line_utils.c:95:	if (seg->col_b != 0 && data->end_color == 0)
draw_line_utils.c:98:		help->color2 = data->end_color;
draw_map.c:50:	while (j < data->line_len[i])
draw_map.c:53:		data->draw_helper.origin.z_origin = (*map)[i][j].z;
draw_map.c:54:		if (j + 1 != data->line_len[i])
draw_map.c:55:			data->draw_helper.right.z_origin = (*map)[i][j + 1].z;
draw_map.c:56:		if (i + 1 != data->len_y)
draw_map.c:57:			data->draw_helper.down.z_origin = (*map)[i + 1][j].z;
draw_map.c:61:			init_origin(&data->draw_helper.origin, &data->draw_helper.right);
draw_map.c:74:	while (i < data->len_y)
draw_map_utils.c:19:	data->rot_hlp.x = x;
draw_map_utils.c:20:	data->rot_hlp.y = y;
draw_map_utils.c:21:	data->rot_hlp.z = z;
draw_map_utils.c:27:		- ((float)data->line_len[0] / 2), (float)i
draw_map_utils.c:28:		- (float)data->len_y / 2, (*map)[i][j].z);
draw_map_utils.c:29:	init_rot(&data->draw_helper.origin, data->rot_hlp, \
draw_map_utils.c:31:	init_rotations(&data->draw_helper.origin, data);
hooks.c:19:	if (data->img.img)
hooks.c:20:		mlx_destroy_image(data->mlx.mlx, data->img.img);
hooks.c:21:	if (data->mlx.win)
hooks.c:22:		mlx_destroy_window(data->mlx.mlx, data->mlx.win);
hooks.c:23:	if (data->mlx.mlx)
hooks.c:25:		mlx_destroy_display(data->mlx.mlx);
hooks.c:26:		free(data->mlx.mlx);
hooks.c:28:	free_map(&(data->map), data->len_y);
hooks.c:29:	free(data->line_len);
hooks.c:30:	exit(data->return_value);
hooks.c:36:	if (data->set_cinematic == true)
hooks.c:45:		data->return_value = EXIT_SUCCESS;
hooks.c:49:	if (data->set_cinematic == true)
hooks.c:67:	mlx_hook(data->mlx.win, 17, (1L << 17), cross_button, data);
hooks.c:68:	mlx_hook(data->mlx.win, 2, KeyPressMask, hooks_handler, data);
hooks.c:69:	mlx_loop_hook(data->mlx.mlx, loop_hook_handler, data);
initialization.c:19:	data->cinematic = 1;
initialization.c:20:	data->cinematic_x = 0;
initialization.c:21:	data->cinematic_y = 0;
initialization.c:22:	data->cinematic_z = 0;
initialization.c:23:	data->set_cinematic = false;
initialization.c:24:	data->fast_mode = true;
initialization.c:29:	data->start_color = 0x00FFFFFF;
initialization.c:30:	data->end_color = 0;
initialization.c:31:	data->set_alpha_mode = false;
initialization.c:32:	data->alpha = 0;
initialization.c:37:	data->fov = 30;
initialization.c:38:	data->special_rendering = false;
initialization.c:39:	data->isometric = true;
initialization.c:44:	data->offset = OFFSET + 1;
initialization.c:49:	line->start_x = data->mlx.w_w / 2;
initialization.c:50:	line->start_y = data->mlx.w_h / 2;
isometric.c:26:	z += data->fov;
isometric.c:29:	if (data->isometric == true)
isometric.c:30:		new_x = x * data->offset;
isometric.c:32:		new_x = x * (data->offset / z);
isometric.c:40:	z += data->fov;
isometric.c:43:	if (data->isometric == true)
isometric.c:44:		new_y = y * data->offset;
isometric.c:46:		new_y = y * (data->offset / z);
main.c:19:	data->border.high_border.a_x = 0;
main.c:20:	data->border.high_border.a_y = 0;
main.c:21:	data->border.high_border.b_x = data->mlx.w_w;
main.c:22:	data->border.high_border.b_y = 0;
main.c:23:	data->border.right_border.a_x = data->mlx.w_w;
main.c:24:	data->border.right_border.a_y = 0;
main.c:25:	data->border.right_border.b_x = data->mlx.w_w;
main.c:26:	data->border.right_border.b_y = data->mlx.w_h;
main.c:27:	data->border.left_border.a_x = 0;
main.c:28:	data->border.left_border.a_y = 0;
main.c:29:	data->border.left_border.b_x = 0;
main.c:30:	data->border.left_border.b_y = data->mlx.w_h;
main.c:31:	data->border.bottom_border.a_x = 0;
main.c:32:	data->border.bottom_border.a_y = data->mlx.w_h;
main.c:33:	data->border.bottom_border.b_x = data->mlx.w_w;	
main.c:34:	data->border.bottom_border.b_y = data->mlx.w_h;	
main.c:40:	data->mlx.mlx = mlx_init();
main.c:41:	if (!data->mlx.mlx)
main.c:43:	data->mlx.w_w = WIN_WIDTH;
main.c:44:	data->mlx.w_h = WIN_HEIGHT;
main.c:45:	data->mlx.win = mlx_new_window(data->mlx.mlx, data->mlx.w_w, \
main.c:46:			data->mlx.w_h, "fdf");
main.c:47:	if (!data->mlx.win)
main.c:49:	data->img.img = mlx_new_image(data->mlx.mlx, data->mlx.w_w, data->mlx.w_h);
main.c:50:	if (!data->img.img)
main.c:52:	data->img.addr = mlx_get_data_addr(data->img.img, \
main.c:53:			&data->img.bits_per_pixel, &data->img.line_lenght, \
main.c:54:			&data->img.endian);
main.c:60:	if (data->set_cinematic == true)
main.c:62:		data->angle.angle_x = data->angle.angle_x
main.c:63:			- data->cinematic_x * data->cinematic;
main.c:64:		data->angle.angle_y = data->angle.angle_y
main.c:65:			- data->cinematic_y * data->cinematic;
main.c:66:		data->angle.angle_z = data->angle.angle_z
main.c:67:			- data->cinematic_z * data->cinematic;
main.c:70:	draw_map(&(data->map), data);
main.c:71:	mlx_put_image_to_window(data->mlx.mlx, data->mlx.win, data->img.img, 0, 0);
main.c:76:	data->return_value = EXIT_FAILURE;
main.c:83:	init_line(&(data->line), data);
mlx.c:35:	if (data->set_alpha_mode == false)
mlx.c:39:		alpha = (data->alpha << 24);
mlx.c:41:		while (y < data->mlx.w_h)
mlx.c:44:			while (x < data->mlx.w_w)
mlx.c:80:	if (data->mlx.w_h < 1920 || data->mlx.w_w < 1080)
mlx.c:81:		pixel_addr = (int *)(data->img.addr) + data->mlx.w_w * y + x;
mlx.c:83:		pixel_addr = ((int *)(data->img.addr)
mlx_utils.c:19:	if (data->img.img != 0)
mlx_utils.c:20:		mlx_destroy_image(data->mlx.mlx, data->img.img);
mlx_utils.c:21:	data->img.img = mlx_new_image(data->mlx.mlx, data->mlx.w_w \
mlx_utils.c:22:		, data->mlx.w_h);
mlx_utils.c:23:	data->img.addr = mlx_get_data_addr(data->img.img \
mlx_utils.c:24:		, &data->img.bits_per_pixel, &data->img.line_lenght, &data->img.endian);
parsing.c:97:	while (y < data->len_y)
parsing.c:105:		data->line_len[y] = len;
parsing.c:107:		while (x < data->line_len[y])
parsing_utils.c:21:	data->z_max = (*map)[0][0].z;
parsing_utils.c:22:	data->z_min = (*map)[0][0].z;
parsing_utils.c:26:		if ((*map)[y][x].z >= data->z_max)
parsing_utils.c:27:			data->z_max = (*map)[y][x].z;
parsing_utils.c:28:		else if ((*map)[y][x].z <= data->z_min)
parsing_utils.c:29:			data->z_min = (*map)[y][x].z;
parsing_utils.c:49:	data->len_y = get_lines(buffer);
parsing_utils.c:50:	data->line_len = malloc(sizeof(int) * data->len_y);
parsing_utils.c:51:	if (!data->line_len)
parsing_utils.c:53:	*map = malloc(sizeof(t_map *) * data->len_y);
parsing_utils.c:55:		return (free(data->line_len), false);
parsing_utils.c:56:	ft_bzero(*map, data->len_y * sizeof(t_map *));
rotates.c:25:	theta = data->angle.angle_z * M_PI / 180;
rotates.c:42:	theta = data->angle.angle_y * M_PI / 180;
rotates.c:59:	theta = data->angle.angle_x * M_PI / 180;
rotates_utils.c:19:	data->angle.angle_x = RA_X;
rotates_utils.c:20:	data->angle.angle_y = RA_Y;
rotates_utils.c:21:	data->angle.angle_z = RA_Z;
rotates_utils.c:26:	if (data->angle.angle_y != 0)
rotates_utils.c:28:	if (data->angle.angle_x != 0)
rotates_utils.c:30:	if (data->angle.angle_z != 0)
rotates_utils.c:36:	if (data->angle.angle_z != 0)
rotates_utils.c:38:	if (data->angle.angle_x != 0)
rotates_utils.c:40:	if (data->angle.angle_y != 0)
truncate_line.c:32:		if (seg->a_x >= data->mlx.w_w)
truncate_line.c:33:			seg->a_x = data->mlx.w_w - 1;
truncate_line.c:34:		if (seg->a_y >= data->mlx.w_h)
truncate_line.c:35:			seg->a_y = data->mlx.w_h - 1;
truncate_line.c:43:	if (x >= 0 && x < data->mlx.w_w)
truncate_line.c:45:		if (y >= 0 && y < data->mlx.w_h)
truncate_line.c:56:		if(check_collide(seg, &data->border.left_border, data))
truncate_line.c:58:	if (seg->a_x >= data->mlx.w_w)
truncate_line.c:59:		if(check_collide(seg, &data->border.right_border, data))
truncate_line.c:62:		if(check_collide(seg, &data->border.high_border, data))
truncate_line.c:64:	if (seg->a_y >= data->mlx.w_h)
truncate_line.c:65:		if(check_collide(seg, &data->border.bottom_border, data))
